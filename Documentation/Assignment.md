# ECEN-361 Lab-02: Clocks, Timers, and Interrupts
### Winter-2025
     Student Name:  Bryant Van Orden


## Introduction and Objective of the Lab

The objectives of this lab are as follows:

- Part 1: Load the LED-D1 Blinky working with a simple timer-based interrupt. Add two more timers to blink LED_D2 and LED_D3 with differing rates.

- Part 2: Reconfigure the timer clock to see the effects of changing the clock source and parameters.

- Part 3: Use a built-in timer to count the time of an external event (button push). This will be done with a fun Reaction timer.

For each of the parts, follow the instructions, then fill in answers to the questions. Expected answers are indicated in brackets like this: \[*answer here*]. Replace the bracketed text with your answer.

The submission for this lab is simply the repository that you'll modify. Your modifications get pushed back to github.com. Your responses, as recorded in this file, will be checked along with your running project.

## Part 1: Adding LEDs to Blinky Application

1. Import with File/Import and point to the directory of the newly cloned project

2. Clean and build the project:

![A screenshot of a computer Description automatically generated](media/7285d1532121002c72aa9e000c8f282b.png)

There should be no errors or warnings.

3. Run the project.
   
   * The project should simply blink the D1_LED once per second.
   
   * No seven-segment display.

### Add 2 more timer interrupts that blink LEDs

* D2_LED: Once every 500 mS.

* D3_LED: Once every 250 mS.

Do this by using the GUI (click on the MX -- .ioc file). Note that two of the timers are already taken:

- DON'T USE TIM17 - it's dedicated to displaying the seven-segment lights
- DON'T USE TIM16 - Note that it's doing D1 at 1 second.

Note that a few things have to happen to make a timer-based interrupt work:

1. The interrupt **must** be enabled in the NVIC settings in the configuration.

2. Timer has to be initialized (this code is generated by the GUI) - see:   
   **MX_TIM17_Init();**

3. Timer has to be started - You put this in main.c see:   
   **HAL_TIM_Base_Start_IT(&htim17);**

4. ISR has to be defined. (Note that the ISR has already been defined for you in this lab) -- You put this in main.c see:
   
   **HAL_TIM_PeriodElapsedCallback(TIM_HandleTypeDef \*htim)**

**Safety tip:**
Note that with the GUI-generated source-codes, anything the USER (you) change that is NOT between the comment sections indicators will be **ERASED**.:

```c
    /* USER CODE BEGIN x*/
    /* USER CODE END   x*/
```


Any modifications you make should *ALWAYS* between these section headers.

## Part 1 Questions (2 pts)

Note the speed of D1/D2/D3 - they should seem like a 3-bit binary counter.

Once you have all three LEDs blinking properly, answer the following questions:

1. At what frequency does D1 toggle? [*answer here*]

     D1 toggles at 1 Hz (Every second)

2. Do all LEDs toggle at *exactly* the same time? [*answer here*]

     No, each LED toggles at different intervals as configured:
          D1: 1 second (1 Hz).
          D2: 500 ms (2 Hz).
          D3: 250 ms (4 Hz).

## Part 2: Changing the clock tree

Change the clock tree to adjust the rates at which the LEDs blink.

1. Open the ioc Configuration GUI
2. Change the APB1 and ABP2-Prescalers to “/8” (Changing both of them guarantees that whatever timer you chose will be affected.)

![A computer screen shot of a diagram Description automatically generated](media/a1a4a08f8ac2f1b714fa0a5456b5e07e.png)

3. Compile and re-run and observe the behavior of the LEDs

## Part 2 Questions (3 pts)

1. What has happened to the speed of the timers? [*answer here*]

The timers run slower due to the reduced input clock.

2. What is the new frequency of LED D1? [*answer here*]

D1 now toggles at 0.125 Hz (once every 8 seconds).

3. When we changed the frequency, did the Seven-Segment Light update rate change?  (hint, look at the clocks driving the APB1, APB2 buses and which timers are on which bus.  Recall that the Seven-Segment timer is Tim17) [*answer here*]

Yes, the Seven-Segment Light update rate also slowed down.

## Part 3: Reaction Timer (5 pts)

In addition to performing useful tasks at set intervals, timers can also be used to measure elapsed time of an event. The events can be triggered by software, or by a hardware input.

For this part of the lab, we'll make a small “reaction timer” that measures how fast your hand/eye coordination can be, in milliseconds.

We'll define the buttons and display as shown:

![](media/2b43c113169efb48ce00225bd55358ff.png)

* **START button (S1):** Initiates a random wait. After the random wait, all the SevenSeg lights go on. As soon as the lights go on, a timer starts counting milliseconds

* **STOP button (S2):** Stops the millisecond reaction timer and shows it on the display

* **FASTEST button (S3):** Extra Credit - This button shows the fastest speed.

Code for this part is organized in the **ReactionTester.c** source file and **main.c**. Fill in between the comments:

```c
/* Student Start HERE */
  /************  STUDENT TO FILL IN HERE START *********************/

    // Add your Timer Start for LED-D2 HERE
    // Add your Timer Start for LED-D3 HERE
  HAL_TIM_Base_Start_IT(&htim6);  // Start Timer for LED-D2
  HAL_TIM_Base_Start_IT(&htim3);  // Start Timer for LED-D3
  if (got_start_button) {
      HAL_TIM_Base_Start(&htim3);  // Start the timer
      got_start_button = false;
  }
  if (got_stop_button) {
      HAL_TIM_Base_Stop(&htim3);  // Stop the timer
      uint32_t elapsed_time = __HAL_TIM_GET_COUNTER(&htim3);
      uint32_t elapsed_time_ms = elapsed_time / 1000;
      MultiFunctionShield_Display(elapsed_time_ms);
      got_stop_button = false;
  }
  HAL_Init();
  SystemClock_Config();
  MX_GPIO_Init();
  MX_USART2_UART_Init();
  MX_TIM17_Init();
  MX_TIM16_Init();
  MX_TIM3_Init();
  MX_TIM6_Init();

  /* Start Necessary Timers */
  HAL_TIM_Base_Start_IT(&htim17); // 7-segment display timer
  MultiFunctionShield_Clear();    // Clear the display



  /************  STUDENT TO FILL IN HERE END   *********************/





  MultiFunctionShield_Clear();
  /* USER CODE END 2 */

  /* Infinite loop */
  /* USER CODE BEGIN WHILE */
  Clear_LEDs();
  printf("\033\143");  // clear the terminal before printing
  printf("Hello Lab-2 -- Timers and Interrupts \n\r\n\r");
  srand((unsigned) uwTick );


  while (1)
  {
    /* USER CODE END WHILE */

    /* USER CODE BEGIN 3 */
	  if (got_start_button && !timer_running)
	      {
	          got_start_button = false; // Reset flag
	          waiting_for_signal = false;
	          timer_running = true;

	          // Show waiting signal
	          MultiFunctionShield_Display(8888); // "Wait"
	          HAL_GPIO_WritePin(LED_D1_GPIO_Port, LED_D1_Pin, GPIO_PIN_RESET);

	          // Random delay (1-7 seconds)
	          int random_delay_ms = (rand() % 7000) + 1000;
	          HAL_Delay(random_delay_ms);

	          // "Go" signal
	          MultiFunctionShield_Clear();
	          HAL_GPIO_WritePin(LED_D1_GPIO_Port, LED_D1_Pin, GPIO_PIN_SET);
	          waiting_for_signal = true;

	          // Start timer
	          __HAL_TIM_SET_COUNTER(&htim3, 0); // Reset counter
	          HAL_TIM_Base_Start(&htim3);
	      }

	      if (got_stop_button)
	      {
	          got_stop_button = false;

	          if (!timer_running)
	          {
	              // Error: Stop button pressed prematurely
	              MultiFunctionShield_Display(9999); // Error code
	          }
	          else
	          {
	              HAL_TIM_Base_Stop(&htim3); // Stop timer
	              uint32_t elapsed_time = __HAL_TIM_GET_COUNTER(&htim3); // Get counter value
	              uint32_t elapsed_time_ms = elapsed_time / 1000; // Convert to milliseconds

	              if (waiting_for_signal)
	              {
	                  // Update fastest time if applicable
	                  if (elapsed_time_ms < best_reaction_time_in_millisec)
	                  {
	                      best_reaction_time_in_millisec = elapsed_time_ms;
	                  }

	                  // Display reaction time
	                  MultiFunctionShield_Display(elapsed_time_ms);

	                  // Reset flags
	                  waiting_for_signal = false;
	                  timer_running = false;

	                  // Turn off "Go" LED
	                  HAL_GPIO_WritePin(LED_D1_GPIO_Port, LED_D1_Pin, GPIO_PIN_RESET);
	              }
	              else
	              {
	                  // Stop button pressed before "Go" signal
	                  MultiFunctionShield_Display(9999); // Error code
	              }
	          }
	      }

	      if (got_fastest_button)
	      {
	          got_fastest_button = false;
	          MultiFunctionShield_Display(best_reaction_time_in_millisec); // Show best time
	      }
  }
  /* USER CODE END 3 */
}

/* Student End HERE */
```

Read thru the comments in the code. Most of the structure is in place, and you should only have to modify places between Student_Start / Student_End.

Note that for the reaction timer to be accurate, because you changed the prescaler above in Part2, you’ll need to reset it back to the default of no-prescale, x1. 

For Seven Segment Display Functions, check the MultiFunctionShield.h header file for applicable display functions.

## Ideas for Credit to get to 'A' & Extra-Credit (2 pts for any)

* In the current code, there's no penalty for “Cheating” by pushing the stop button before all the “Go” lights turn on.  Implement some sort of indicator that the
  Stop button was pushed prematurely.

* Change the “Go” lights to be all of the D1..4 LEDs instead of displaying '8888' on the SevenSegments.

* Make the final reaction time flash on/off

* Currently, the reaction tester can have a wait time anywhere between 0 and 7000 milliseconds, Implement a minimum wait time in such a way that doesn't change the potential maximum wait time

If you do any of these items - just mention what and how it worked, [*here*].
I added the feature that it would display 9999 if you did it too early. I got it working so that it doesn't start with zero as wellit it has a mininmum wait time. 
